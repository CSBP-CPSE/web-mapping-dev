(function () {
    'use strict';

    var nls = {
      "Toc_Instruction": {
        "en": "Turn layers on or off",
        "fr": "Afficher ou cachers les couches"
      },
      "Toc_Legend": {
        "en": "Legend",
        "fr": "Légende"
      },
      "Toc_Opacity": {
        "en": "Opacity",
        "fr": "Opacité"
      },
      "Splash_LODE_Title": {
        "en": "LODE Viewer",
        "fr": "Visionneuse de l'ECDO"
      },
      "Splash_LODE_1": {
        "en": "The Linkable Open Data Environment (LODE) is an exploratory initiative that aims at enhancing the use and harmonization of open micro data primarily from municipal, provincial and federal sources.",
        "fr": "L'Environnement de couplage de données ouvertes (ECDO) est une initiative exploratoire qui vise à accroître l'utilisation et l'harmonisation de microdonnées ouvertes provenant principalement de sources municipales, provinciales et fédérales."
      },
      "Splash_LODE_2": {
        "en": "The results are a collection of datasets released under a single open data license (Open Government Licence - Canada), as well as open source tools used to process the data, and collaborations in an open space.",
        "fr": "Il en résulte une collection d'ensembles de données diffusés en vertu d'une même licence de données ouvertes (Licence du gouvernement ouvert – Canada), ainsi que des outils libres utilisés pour traiter les données et des collaborations dans un espace ouvert."
      },
      "Splash_LODE_3": {
        "en": "The LODE is implemented by the Data Exploration and Integration Lab (DEIL). Thus, it is an ongoing and exploratory initiative, developed in an open space, as an open project.",
        "fr": "L'ECDO est mis en œuvre par le Laboratoire d'exploration et d'intégration des données. Il s'agit par conséquent d'une initiative continue et exploratoire mise sur pied dans un espace ouvert à titre de projet ouvert."
      },
      "Splash_WIP": {
        "en": "The LODE Viewer is a work in progress. We are aware of certain issues. Notably, certain census boundaries are incorrect.",
        "fr": "La visionneuse de l'ECDO est un travail en cours. Nous sommes conscient de certains problèmes. Notamment, certaines limites de recensement sont incorrectes."
      },
      "Splash_Warning": {
        "en": "Warning: This web application consumes a large amount of data. It is advised not to use it on a mobile device with a limited data plan.",
        "fr": "Attention : Cette application consomme un grand volume de données. Il est conseillé de ne pas l'utiliser sur une plateforme mobile avec un plan de données limité."
      },
      "Splash_Continue": {
        "en": "CONTINUE",
        "fr": "CONTINUER"
      }
    };

    var config = {
      layers: ["pr", "cd", "csd", "da", "db"],
      title: {
        "en": "Population to Building Ratio",
        "fr": "Proportion de population par bâtiment"
      },
      legend: [{
        color: [230, 230, 230],
        label: {
          en: "0 Buildings, 0 Population",
          fr: "0 bâtiments, 0 population"
        }
      }, {
        color: [204, 102, 153],
        label: {
          en: "0 Population",
          fr: "0 population"
        }
      }, {
        color: [204, 255, 51],
        label: {
          en: "0 Buildings",
          fr: "0 bâtiments"
        }
      }, {
        color: [161, 218, 180],
        label: {
          en: "Between 0 et 1.5",
          fr: "Entre 0 et 1.5"
        }
      }, {
        color: [255, 255, 204],
        label: {
          en: "Between 1.5 et 3",
          fr: "Entre 1.5 et 3"
        }
      }, {
        color: [65, 182, 196],
        label: {
          en: "Between 3 et 7",
          fr: "Entre 3 et 7"
        }
      }, {
        color: [44, 127, 184],
        label: {
          en: "Between 7 et 20",
          fr: "Entre 7 et 20"
        }
      }, {
        color: [37, 52, 148],
        label: {
          en: "More than 20",
          fr: "Plus de 20"
        }
      }],
      toc: [{
        id: "pr",
        label: {
          en: "Province (PR)",
          fr: "Province (PR)"
        }
      }, {
        id: "cd",
        label: {
          en: "Census Division (CD)",
          fr: "Division de recensement (DR)"
        }
      }, {
        id: "csd",
        label: {
          en: "Census Subdivision (CSD)",
          fr: "Sous-division de recensement (SDR)"
        }
      }, {
        id: "da",
        label: {
          en: "Dissemination Area (DA)",
          fr: "Aire de diffusion (AD)"
        }
      }, {
        id: "db",
        label: {
          en: "Dissemination Block (DB)",
          fr: "Bloc de diffusion (BD)"
        }
      }],
      selected: "da",
      classes: ['case', ['all', ['==', ['get', 'population'], 0], ['==', ['get', 'buildings'], 0]], '#color1', ['==', ['get', 'population'], 0], '#color2', ['==', ['get', 'buildings'], 0], '#color3', ['<', ['/', ['get', 'population'], ['get', 'buildings']], 1.5], '#color4', ['<', ['/', ['get', 'population'], ['get', 'buildings']], 3], '#color5', ['<', ['/', ['get', 'population'], ['get', 'buildings']], 7], '#color6', ['<', ['/', ['get', 'population'], ['get', 'buildings']], 20], '#color7', '#color8'],
      fields: [{
        id: "uid",
        label: {
          en: "ID",
          fr: "ID"
        }
      }, {
        id: "name",
        label: {
          en: "Name",
          fr: "Nom"
        }
      }, {
        id: "name_en",
        label: {
          en: "Name (english)",
          fr: "Nom (anglais)"
        }
      }, {
        id: "name_fr",
        label: {
          en: "Name (french)",
          fr: "Nom (français)"
        }
      }, {
        id: "population",
        label: {
          en: "Population",
          fr: "Population"
        }
      }, {
        id: "buildings",
        label: {
          en: "Buildings",
          fr: "Bâtiments"
        }
      }, {
        id: "ratio",
        label: {
          en: "Ratio",
          fr: "Proportion"
        },
        polish: ["/", "population", "buildings"]
      }]
    };

    var config$1 = {
      layers: ["bc", "ab", "sk", "mb", "on", "qc", "pe", "ns", "nb", "nl", "nt", "nu", "yt"],
      title: {
        "en": "Data Provenance",
        "fr": "Source des données"
      },
      legend: [{
        color: [77, 148, 242],
        label: {
          en: "Microsoft",
          fr: "Microsoft"
        }
      }, {
        color: [240, 82, 43],
        label: {
          en: "Statistics Canada (ODB)",
          fr: "Statistique Canada (BDOI)"
        }
      }],
      classes: ['case', ['==', ['get', 'Data_prov'], 'Microsoft'], '#color1', '#color2'],
      fields: [{
        id: "Data_prov",
        label: {
          en: "Origin",
          fr: "Source"
        }
      }, {
        id: "PRUID",
        label: {
          en: "PR",
          fr: "PR"
        }
      }, {
        id: "CDUID",
        label: {
          en: "CD",
          fr: "DR"
        }
      }, {
        id: "CSDUID",
        label: {
          en: "CSD",
          fr: "SDR"
        }
      }, {
        id: "DAUID",
        label: {
          en: "DA",
          fr: "AD"
        }
      }, {
        id: "DBUID",
        label: {
          en: "DB",
          fr: "BD"
        }
      }]
    };

    var config$2 = {
      layers: ["bc", "ab", "sk", "mb", "on", "qc", "pe", "ns", "nb", "nl", "nt", "nu", "yt"],
      title: {
        "en": "Area per vertex",
        "fr": "Surface par vertex"
      },
      legend: [{
        color: [255, 255, 178],
        label: {
          en: "Between 0 et 20 sqm/v",
          fr: "Entre 0 et 20 m2/v"
        }
      }, {
        color: [254, 204, 92],
        label: {
          en: "Between 20 et 100 sqm/v",
          fr: "Entre 20 et 100 m2/v"
        }
      }, {
        color: [253, 141, 60],
        label: {
          en: "Between 100 et 500 sqm/v",
          fr: "Entre 100 et 500 m2/v"
        }
      }, {
        color: [240, 59, 32],
        label: {
          en: "Between 500 et 5000 sqm/v",
          fr: "Entre 500 et 5000 m2/v"
        }
      }, {
        color: [189, 0, 38],
        label: {
          en: "More than 5000 sqm/v",
          fr: "Plus de 5000 m2/v"
        }
      }],
      classes: ['case', ['<', ['get', 'area_vert'], 20], '#color1', ['<', ['get', 'area_vert'], 100], '#color2', ['<', ['get', 'area_vert'], 500], '#color3', ['<', ['get', 'area_vert'], 5000], '#color4', '#color5'],
      fields: [{
        id: "area",
        label: {
          en: "Area",
          fr: "Superficie"
        },
        fixed: 2
      }, {
        id: "area_vert",
        label: {
          en: "Area to vertices",
          fr: "Surface à vertex"
        },
        fixed: 2
      }, {
        id: "perimeter",
        label: {
          en: "Perimeter",
          fr: "Périmètre"
        },
        fixed: 2
      }, {
        id: "peri_vert",
        label: {
          en: "Perimeter to vertices",
          fr: "Périmètre à vertex"
        },
        fixed: 2
      }]
    };

    var config$3 = {
      layers: ["db"],
      title: {
        "en": "Proximity to public transit routes (index)",
        "fr": "Proximité aux routes de transport en commun (index)"
      },
      legend: [{
        color: [255, 255, 255],
        label: {
          en: "Not available",
          fr: "Non-disponible"
        }
      }, {
        color: [255, 255, 178],
        label: {
          en: "Between 0.00 and 0.02",
          fr: "Entre 0.00 et 0.02"
        }
      }, {
        color: [254, 204, 92],
        label: {
          en: "Between 0.02 and 0.05",
          fr: "Entre 0.02 et 0.05"
        }
      }, {
        color: [253, 141, 60],
        label: {
          en: "Between 0.05 and 0.12",
          fr: "Entre 0.05 et 0.12"
        }
      }, {
        color: [240, 59, 32],
        label: {
          en: "Between 0.12 and 0.20",
          fr: "Entre 0.12 et 0.20"
        }
      }, {
        color: [189, 0, 38],
        label: {
          en: "Between 0.20 and 0.40",
          fr: "Entre 0.20 et 0.40"
        }
      }, {
        color: [129, 0, 38],
        label: {
          en: "More than 0.40",
          fr: "Plus de 0.40"
        }
      }],
      selected: "db",
      classes: ['case', ['==', ['get', 'routes_prx'], null], '#color1', ['<', ['get', 'routes_prx'], 0.02], '#color2', ['<', ['get', 'routes_prx'], 0.05], '#color3', ['<', ['get', 'routes_prx'], 0.12], '#color4', ['<', ['get', 'routes_prx'], 0.2], '#color5', ['<', ['get', 'routes_prx'], 0.4], '#color6', '#color7'],
      fields: [{
        id: "routes_prx",
        label: {
          en: "Proximity to public transit route",
          fr: "Proximité aux routes de transport en commun"
        },
        fixed: 4
      }]
    };

    var config$4 = {
      layers: ["db"],
      title: {
        "en": "Proximity to public transit trips (index)",
        "fr": "Proximité aux voyages de transport en commun (index)"
      },
      legend: [{
        color: [204, 255, 51],
        label: {
          en: "Not available",
          fr: "Non-disponible"
        }
      },{
        color: [255, 255, 255],
        label: {
          en: "Equal to 0.000",
          fr: "Égal à 0.000"
        }
      }, {
        color: [255, 255, 204],
        label: {
          en: "Between 0.000 and 0.085",
          fr: "Entre 0.000 et 0.085"
        }
      }, {
        color: [220, 251, 230],
        label: {
          en: "Between 0.085 and 0.310",
          fr: "Entre 0.085 et 0.31"
        }
      }, {
        color: [161, 218, 180],
        label: {
          en: "Between 0.310 and 0.800",
          fr: "Entre 0.310 et 0.800"
        }
      }, {
        color: [65, 182, 196],
        label: {
          en: "Between 0.800 and 1.000",
          fr: "Entre 0.800 et 1.000"
        }
      }, {
        color: [44, 127, 184],
        label: {
          en: "Between 1.000 and 2.000",
          fr: "Entre 1.000 et 2.000"
        }
      }, {
        color: [37, 52, 148],
        label: {
          en: "More than 2.000",
          fr: "Plus de 2.000"
        }
      }],
      selected: "db",
      classes: ['case', ['==', ['get', 'trips_prx'], null], '#color1', ['==', ['get', 'trips_prx'], 0], '#color2', ['<', ['get', 'trips_prx'], 0.085], '#color3', ['<', ['get', 'trips_prx'], 0.31], '#color4', ['<', ['get', 'trips_prx'], 0.8], '#color5', ['<', ['get', 'trips_prx'], 1], '#color6', ['<', ['get', 'trips_prx'], 2], '#color7', '#color8'],
      fields: [{
        id: "trips_prx",
        label: {
          en: "Proximity to public transit trip",
          fr: "Proximité aux voyages de transport en commun"
        },
        fixed: 4
      }]
    };

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }

    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }

    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf(o, p);
    }

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized(self);
    }

    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null) break;
      }

      return object;
    }

    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get(target, property, receiver) {
          var base = _superPropBase(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get(target, property, receiver || target);
    }

    var Util =
    /*#__PURE__*/
    function () {
      function Util() {
        _classCallCheck(this, Util);
      }

      _createClass(Util, null, [{
        key: "Mixin",

        /**
        * Merges an object into another object. 
        *
        * Parameters :
        *	a : Object, the object that will receive the properties 
        *	b : Object, the object to merge into object A
        * Return : the modified Object
        */
        value: function Mixin(a, b) {
          for (var key in b) {
            if (b.hasOwnProperty(key)) a[key] = b[key];
          } // TODO : Why did I use arguments[0] instead of a?


          return arguments[0];
        }
        /**
        * Debounces a function. The function will be executed after a timeout 
        * unless the function is called again in which case, the timeout will
        * reset
        *
        * Parameters :
        *	delegate : Function, the Function to debounce
        *	threshold : Integer, the timeout length, in milliseconds
        * Return : Function, the debounced function
        */

      }, {
        key: "Debounce",
        value: function Debounce(delegate, threshold) {
          var timeout;
          return function debounced() {
            function delayed() {
              delegate.apply(this, arguments);
              timeout = null;
            }

            if (timeout) clearTimeout(timeout);
            timeout = setTimeout(delayed.bind(this), threshold || 100);
          };
        }
        /**
        * Formats a String using substitute strings
        *
        * Parameters :
        *	str : String, the String to format
        *	subs : Array(String), An array of Strings to substitute into the String
        * Return : String, the formatted String
        */

      }, {
        key: "Format",
        value: function Format(str, subs) {
          if (!subs || subs.length == 0) return str;
          var s = str;

          for (var i = 0; i < subs.length; i++) {
            var reg = new RegExp("\\{" + i + "\\}", "gm");
            s = s.replace(reg, subs[i]);
          }

          return s;
        }
      }]);

      return Util;
    }();

    var Dom =
    /*#__PURE__*/
    function () {
      function Dom() {
        _classCallCheck(this, Dom);
      }

      _createClass(Dom, null, [{
        key: "Node",

        /**
        * Retrieve an Element using a selector
        *
        * Parameters :
        *	pNode : Element, the parent node where to begin the search
        *	selector : String, a selector statement
        * Return : Element, the Element found, null otherwise
        */
        value: function Node(pNode, selector) {
          return pNode.querySelectorAll(selector).item(0) || null;
        }
        /**
        * Create an Element
        *
        * Parameters :
        *	tagName : String, the type of Element to be created (div, span, label, input, etc.)
        *	options : Object, a dictionary type object containing the options to assign to the created Element
        *	pNode : Element, the parent Element where the created Element will be apended
        * Return : Element, The Element created
        */

      }, {
        key: "Create",
        value: function Create(tagName, options, pNode) {
          var elem = document.createElement(tagName);
          Util.Mixin(elem, options);
          this.Place(elem, pNode);
          return elem;
        }
        /**
        * Create an SVG Element
        *
        * Parameters :
        *	tagName : String, the type of SVG Element to be created (rect, path, etc.)
        *	options : Object, a dictionary type object containing the options to assign to the created SVG Element
        *	pNode : Element, the parent Element where the created SVG Element will be apended
        * Return : Element, The SVG Element created
        */

      }, {
        key: "CreateSVG",
        value: function CreateSVG(tagName, options, pNode) {
          var elem = document.createElementNS("http://www.w3.org/2000/svg", tagName);

          for (var id in options) {
            elem.setAttribute(id, options[id]);
          }

          this.Place(elem, pNode);
          return elem;
        }
        /**
        * Create an Element from a namespace
        *
        * Parameters :
        *	ns : String, the URI namespace containing the Element to create 
        *	tagName : String, the type of Element to be created (rect, path, etc.)
        *	options : Object, a dictionary type object containing the options to assign to the created Element
        *	pNode : Element, the parent Element where the created Element will be apended
        *
        * Valid Namespaces are : 
        *	HTML : http://www.w3.org/1999/xhtml
        *	SVG  : http://www.w3.org/2000/svg
        *	XBL  : http://www.mozilla.org/xbl
        *	XUL  : http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul
        *
        * Return : Element, The SVG Element created
        */

      }, {
        key: "CreateNS",
        value: function CreateNS(ns, tagName, options, pNode) {
          var elem = document.createElementNS(ns, tagName);

          for (var id in options) {
            elem.setAttribute(id, options[id]);
          }

          this.Place(elem, pNode);
          return elem;
        }
        /**
        * Append an Element to another Element
        *
        * Parameters :
        *	elem : Element, the Element to append
        *	pNode : Element, the parent Element where the Element will be apended
        * Return : none
        */

      }, {
        key: "Place",
        value: function Place(elem, pNode) {
          if (!!pNode) pNode.appendChild(elem);
        }
        /**
        * Replace an Element by another Element
        *
        * Parameters :
        *	elem1 : Element, the Element to be replaced
        *	elem2 : Element, the Element that will replace elem1
        * Return : none
        */

      }, {
        key: "Replace",
        value: function Replace(elem1, elem2) {
          var pNode = elem1.parentNode;
          pNode.insertBefore(elem2, elem1);
          this.Remove(elem1, pNode);
        }
        /**
        * Remove an Element from another Element
        *
        * Parameters :
        *	elem : Element, the Element to remove
        *	pNode : Element, the parent Element containing the Element to remove
        * Return : none
        */

      }, {
        key: "Remove",
        value: function Remove(elem, pNode) {
          if (!pNode.children.some(function (child) {
            return child === elem;
          })) return;
          pNode.removeChild(elem);
        }
        /**
        * Remove all children of an Element
        *
        * Parameters :
        *	elem : Element, the Element to empty
        * Return : none
        */

      }, {
        key: "Empty",
        value: function Empty(elem) {
          while (elem.firstChild) {
            elem.removeChild(elem.firstChild);
          }
        }
        /**
        * Add a CSS rule on an Element
        *
        * Parameters :
        *	elem : Element, the Element to modify
        *	css : String, the CSS rule to add on the Element
        * Return : none
        */

      }, {
        key: "AddCss",
        value: function AddCss(elem, css) {
          var c1 = elem.className.split(" ");
          css.split(" ").forEach(function (c) {
            if (!c1.includes(c)) c1.push(c);
          });
          elem.className = c1.join(" ");
        }
        /**
        * Remove a CSS rule on an Element
        *
        * Parameters :
        *	elem : Element, the Element to modify
        *	css : String, the CSS rule to remove from the Element
        * Return : none
        */

      }, {
        key: "RemoveCss",
        value: function RemoveCss(elem, css) {
          var c1 = elem.className.split(" ");
          var c2 = css.split(" ");
          c1.filter(function (c) {
            return c2.indexOf(c) == -1;
          });
          elem.className = classes.join(" ");
        }
        /**
        * Verify that an Element contains a CSS rule
        *
        * Parameters :
        *	elem : Element, the Element to verify
        *	css : String, the CSS rule to find
        * Return : Boolean, true if the Element contains the CSS rule, false otherwise
        */

      }, {
        key: "HasCss",
        value: function HasCss(elem, css) {
          return (' ' + elem.className + ' ').indexOf(' ' + css + ' ') > -1;
        }
        /**
        * Set the CSS rules on an Element
        *
        * Parameters :
        *	elem : Element, the Element to modify
        *	css : String, the CSS rule to set on the Element
        * Return : none
        */

      }, {
        key: "SetCss",
        value: function SetCss(elem, css) {
          elem.className = css;
        }
        /**
        * Toggle a CSS rule on or or off for an Element
        *
        * Parameters :
        *	elem : Element, the Element to modify
        *	css : String, the CSS rule to toggle on the Element
        *	enabled : Boolean, true to toggle the CSS rule on, false to toggle it off
        * Return : none
        */

      }, {
        key: "ToggleCss",
        value: function ToggleCss(elem, css, enabled) {
          if (enabled) this.AddCss(elem, css);else this.RemoveCss(elem, css);
        }
        /**
        * Get an attribute value from an Element
        *
        * Parameters :
        *	elem : Element, the Element to retrieve the attribute from
        *	attr : String, the name of the attribute to retrieve
        * Return : String, the value of the attribute if found, null otherwise
        */

      }, {
        key: "GetAttribute",
        value: function GetAttribute(elem, attr) {
          var attr = elem.attributes.getNamedItem(attr);
          return attr ? attr.value : null;
        }
        /**
        * Set an attribute value on an Element
        *
        * Parameters :
        *	elem : Element, the Element to set the attribute on
        *	attr : String, the name of the attribute to set
        *	value : String, the value of the attribute to set
        * Return : none
        */

      }, {
        key: "SetAttribute",
        value: function SetAttribute(elem, attr, value) {
          elem.setAttribute(attr, value);
        }
        /**
        * Get the size of an Element
        *
        * Parameters :
        *	elem : Element, the Element to retrieve the size
        * Return : Object, an object literal containing the size of the Element
        * 
        * { 
        *	w: width of the Element, 
        *	h: height of the Element 
        * }
        */

      }, {
        key: "Size",
        value: function Size(elem) {
          var style = window.getComputedStyle(elem);
          var h = +style.getPropertyValue("height").slice(0, -2);
          var w = +style.getPropertyValue("width").slice(0, -2);
          var pL = +style.getPropertyValue("padding-left").slice(0, -2);
          var pR = +style.getPropertyValue("padding-right").slice(0, -2);
          var pT = +style.getPropertyValue("padding-top").slice(0, -2);
          var pB = +style.getPropertyValue("padding-bottom").slice(0, -2);
          var w = w - pL - pR;
          var h = h - pT - pB; // Use smallest width as width and height for square grid that fits in container
          // var s = w < h ? w : h;

          return {
            w: w,
            h: h
          };
        }
      }]);

      return Dom;
    }();

    var _nls = null;
    var _locale = null;
    var _templatables = {};

    var Core =
    /*#__PURE__*/
    function () {
      function Core() {
        _classCallCheck(this, Core);
      }

      _createClass(Core, null, [{
        key: "Nls",

        /**
        * Get a localized nls string ressource
        *
        * Parameters :
        *	id : String, the id of the nls ressource to retrieve
        *	subs : Array(String), an array of Strings to substitute in the localized nls string ressource
        *	locale : String, the locale for the nls ressource
        * Return : String, the localized nls string ressource
        */
        value: function Nls(id, subs, locale) {
          if (!this.nls) throw new Error("Nls content not set.");
          var itm = this.nls[id];
          if (!itm) throw new Error("Nls String '" + id + "' undefined.");
          var txt = itm[locale ? locale : this.locale];
          if (txt === undefined || txt === null) throw new Error("String does not exist for requested language.");
          return Util.Format(txt, subs);
        }
        /**
        * A convenience function to get a deffered object for asynchronous processing. 
        * Removes one level of nesting when working with promises
        *
        * Parameters :
        *	none
        * Return : Object, an object with a Resolve and Reject function
        *
        * { 
        *	promise: the promise object associated to the asynchronous process, 
        *	Resolve: a function to resolve the promise, 
        *	Reject: a function to reject the promise 
        * }
        */

      }, {
        key: "Defer",
        value: function Defer() {
          var defer = {};
          defer.promise = new Promise(function (resolve, reject) {
            defer.Resolve = function (result) {
              resolve({
                result: result
              });
            };

            defer.Reject = function (error) {
              reject({
                error: error
              });
            };
          });
          return defer;
        }
        /**
        * Get or set a templated class definition, this is required to nest Templated UI 
        * components within other Templated UI components.
        *
        * Parameters :
        *	id : String, the id of the templated class definition to get or set
        *	definition : Class, when specified, the class definition to set 
        * Return : Class, the class definition created  
        */

      }, {
        key: "Templatable",
        value: function Templatable(id, definition) {
          if (definition) {
            if (_templatables[id]) throw new Error("Templatable ".concat(id, " is defined multiple times."));else _templatables[id] = definition;
          } else if (!_templatables[id]) throw new Error("Templatable ".concat(id, " is not defined."));

          return _templatables[id];
        }
        /**
        * Get an Array of class definitions by matching its
        *
        * Parameters :
        *	id : String, the id of the nls ressource to retrieve
        *	subs : Array(String), an array of Strings to substitute in the localized nls string ressource
        *	locale : String, the locale for the nls ressource
        * Return : String, the localized nls string ressource
        */

      }, {
        key: "Templated",
        value: function Templated(namespace) {
          var templated = [];

          for (var id in _templatables) {
            if (id.match(namespace)) templated.push(_templatables[id]);
          }

          return templated;
        }
      }, {
        key: "nls",

        /**
        * Gets the nls ressources
        *
        * Return : Object, an object containing the nls ressources
        */
        get: function get() {
          return _nls;
        }
        /**
        * Sets the nls ressources
        */
        ,
        set: function set(value) {
          _nls = value;
        }
        /**
        * Gets the locale String
        *
        * Return : String, a String containing the locale
        */

      }, {
        key: "locale",
        get: function get() {
          return _locale;
        }
        /**
        * Sets the locale String
        */
        ,
        set: function set(value) {
          _locale = value;
        }
      }]);

      return Core;
    }();

    var Evented =
    /*#__PURE__*/
    function () {
      function Evented() {
        _classCallCheck(this, Evented);

        this.listeners = {};
      }

      _createClass(Evented, [{
        key: "addEventListener",
        value: function addEventListener(type, callback, once) {
          if (!(type in this.listeners)) this.listeners[type] = [];
          var h = {
            target: this,
            type: type,
            callback: callback,
            once: !!once
          };
          this.listeners[type].push(h);
          return h;
        }
      }, {
        key: "removeEventListener",
        value: function removeEventListener(type, callback) {
          if (!(type in this.listeners)) return;
          var stack = this.listeners[type];

          for (var i = 0, l = stack.length; i < l; i++) {
            if (stack[i].callback === callback) {
              stack.splice(i, 1);
              return this.removeEventListener(type, callback);
            }
          }
        }
      }, {
        key: "dispatchEvent",
        value: function dispatchEvent(event) {
          if (!(event.type in this.listeners)) return;
          var stack = this.listeners[event.type];
          event.target = this;

          for (var i = 0; i < stack.length; i++) {
            stack[i].callback.call(this, event);
          }

          for (var i = stack.length - 1; i >= 0; i--) {
            if (!!stack[i].once) this.removeEventListener(event.type, stack[i].callback);
          }
        }
      }, {
        key: "Emit",
        value: function Emit(type, data) {
          var event = {
            type: type,
            bubbles: true,
            cancelable: true
          };
          Util.Mixin(event, data);
          this.dispatchEvent(event);
        }
      }, {
        key: "On",
        value: function On(type, callback) {
          return this.addEventListener(type, callback, false);
        }
      }, {
        key: "Once",
        value: function Once(type, callback) {
          return this.addEventListener(type, callback, true);
        }
      }, {
        key: "Off",
        value: function Off(type, callback) {
          this.removeEventListener(type, callback);
        }
      }]);

      return Evented;
    }();

    var Templated =
    /*#__PURE__*/
    function (_Evented) {
      _inherits(Templated, _Evented);

      function Templated(container, options) {
        var _this;

        _classCallCheck(this, Templated);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(Templated).call(this));
        _this.options = options || {};

        _this.BuildTemplate();

        if (_this.template) _this.SetNamedNodes();
        if (_this.template) _this.BuildSubWidgets();
        if (container) _this.Place(container);
        return _this;
      }

      _createClass(Templated, [{
        key: "BuildTemplate",
        value: function BuildTemplate() {
          // Use template provided in options first, use Template function second
          var html = this.options.template ? this.options.template : this.Template(); // TODO : I think it still works with empty templates.

          if (!html) return; // Trailing whitespaces can cause issues when parsing the template, remove them

          html = html.trim(); // Replace all nls strings in template. Nls string pattern in templates is nls(StringId)

          html = this.Replace(html, /nls\((.*?)\)/, function (m) {
            return Core.Nls(m);
          });
          this.template = Dom.Create("div", {
            innerHTML: html
          });
        }
      }, {
        key: "SetNamedNodes",
        value: function SetNamedNodes() {
          var named = this.template.querySelectorAll("[handle]");
          this.nodes = {}; // Can't use Array ForEach here since named is a NodeList, not an array

          for (var i = 0; i < named.length; i++) {
            var name = Dom.GetAttribute(named[i], "handle");
            this.nodes[name] = named[i];
          }
        }
      }, {
        key: "BuildSubWidgets",
        value: function BuildSubWidgets() {
          var nodes = this.template.querySelectorAll("[widget]");

          for (var i = 0; i < nodes.length; i++) {
            var path = Dom.GetAttribute(nodes[i], "widget");
            var module = Core.Templatable(path);
            var widget = new module(nodes[i]);
            var handle = Dom.GetAttribute(widget.container, "handle");
            if (handle) this.nodes[handle] = widget;
          }
        }
      }, {
        key: "Place",
        value: function Place(container) {
          this.container = container;
          if (!this.template) return;

          while (this.template.children.length > 0) {
            Dom.Place(this.template.children[0], this.container);
          }
        }
      }, {
        key: "Template",
        value: function Template() {
          return null;
        }
      }, {
        key: "Replace",
        value: function Replace(str, expr, delegate) {
          var m = str.match(expr);

          while (m) {
            str = str.replace(m[0], delegate(m[1]));
            m = str.match(expr);
          }

          return str;
        }
      }, {
        key: "Node",
        value: function Node(id) {
          return this.nodes[id];
        }
      }]);

      return Templated;
    }(Evented);

    var Popup =
    /*#__PURE__*/
    function (_Templated) {
      _inherits(Popup, _Templated);

      _createClass(Popup, [{
        key: "Content",
        set: function set(content) {
          this.content = content;
          Dom.Place(content, this.Node("body"));
        },
        get: function get() {
          return this.content;
        }
      }]);

      function Popup() {
        var _this;

        _classCallCheck(this, Popup);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(Popup).call(this, document.body));
        _this.content = null;

        _this.Node("close").addEventListener("click", _this.onBtnClose_Click.bind(_assertThisInitialized(_this)));

        _this.Hide();

        return _this;
      }

      _createClass(Popup, [{
        key: "Show",
        value: function Show() {
          this.Node("root").style.opacity = 1;
          this.Node("root").style.visibility = "visible";
        }
      }, {
        key: "Hide",
        value: function Hide() {
          this.Node("root").style.opacity = 0;
          this.Node("root").style.visibility = "hidden";
        }
      }, {
        key: "onBtnClose_Click",
        value: function onBtnClose_Click(ev) {
          this.Hide();
        }
      }, {
        key: "Template",
        value: function Template() {
          return "<div handle='root' class='popup'>" + "<div class='popup-container'>" + "<div class='popup-header'>" + "<div class='popup-title' handle='title'></div>" + "<button class='close' handle='close'>×</button>" + "</div>" + "<div class='popup-body' handle='body'></div>" + "</div>" + "</div>";
        }
      }]);

      return Popup;
    }(Templated);

    var Splash =
    /*#__PURE__*/
    function (_Popup) {
      _inherits(Splash, _Popup);

      function Splash() {
        var _this;

        _classCallCheck(this, Splash);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(Splash).call(this));

        _this.Node("continue").addEventListener("click", function (ev) {
          this.onBtnClose_Click(ev);
          this.callback();
        }.bind(_assertThisInitialized(_this)));

        return _this;
      }

      _createClass(Splash, [{
        key: "onBtnClose_Click",
        value: function onBtnClose_Click(ev) {
          _get(_getPrototypeOf(Splash.prototype), "onBtnClose_Click", this).call(this, ev);

          this.callback();
        }
      }, {
        key: "Show",
        value: function Show(callback) {
          _get(_getPrototypeOf(Splash.prototype), "Show", this).call(this); // TODO : Need to use promise but stupid ie11


          this.callback = callback;
        }
      }, {
        key: "Template",
        value: function Template() {
          return "<div handle='root' class='popup modal'>" + "<div class='popup-container'>" + "<button class='close' handle='close'>×</button>" + "<div class='popup-body' handle='body'>" + "<h1>nls(Splash_LODE_Title)</h1>" + "<hr>" + "<p class='warning'>nls(Splash_Warning)</p>" + "<hr>" + "<p>nls(Splash_LODE_1)</p>" + "<div class='logo-container'>" + "<img class='logo' src='assets/lode-logo.png' />" + "</div>" + "<p>nls(Splash_LODE_2)</p>" + "<p>nls(Splash_LODE_3)</p>" + "<hr>" + "<div class='wip-container'>" + "<div><img src='assets/warning.png' /></div>" + "<div>nls(Splash_WIP)</div>" + "</div>" + "<div class='continue-container'>" + "<button class='continue' handle='continue'>nls(Splash_Continue)</button>" + "</div>" + "</div>" + "</div>" + "</div>";
        }
      }]);

      return Splash;
    }(Popup);

    var Map =
    /*#__PURE__*/
    function () {
      function Map() {
        _classCallCheck(this, Map);
      }

      _createClass(Map, null, [{
        key: "InfoPopup",
        value: function InfoPopup(map, lngLat, html) {
          var popup = new mapboxgl.Popup({
            closeOnClick: true
          }).setLngLat(lngLat).setHTML(html).addTo(map);
        }
      }, {
        key: "Choropleth",
        value: function Choropleth(map, layers, classes) {
          layers.forEach(function (l) {
            map.setPaintProperty(l, 'fill-color', classes);
          });
        }
      }, {
        key: "ReorderLayers",
        value: function ReorderLayers(map, layers) {
          layers.forEach(function (l) {
            map.moveLayer(l);
          });
        }
      }, {
        key: "Token",
        set: function set(value) {
          mapboxgl.accessToken = value;
        },
        get: function get() {
          return mapboxgl.accessToken;
        }
      }]);

      return Map;
    }();

    var Control =
    /*#__PURE__*/
    function (_Templated) {
      _inherits(Control, _Templated);

      function Control(options) {
        var _this;

        _classCallCheck(this, Control);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(Control).call(this, null, options));
        if (!_this.template) throw new Error("MapBox controls cannot be empty");
        if (_this.template.children.length > 1) throw new Error("MapBox controls should have one root node");
        _this._container = _this.template.children[0];
        return _this;
      }

      _createClass(Control, [{
        key: "onAdd",
        value: function onAdd(map) {
          this._map = map;
          return this._container;
        }
      }, {
        key: "onRemove",
        value: function onRemove() {
          this._container.parentNode.removeChild(this._container);

          this._map = undefined;
        }
      }]);

      return Control;
    }(Templated);

    var Legend =
    /*#__PURE__*/
    function (_Control) {
      _inherits(Legend, _Control);

      _createClass(Legend, [{
        key: "opacity",
        get: function get() {
          return this.Node('slider').value / 100;
        }
      }]);

      function Legend(options) {
        var _this;

        _classCallCheck(this, Legend);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(Legend).call(this, options));
        _this._container = _this.Node('root');
        _this.radios = {};

        if (_this.options.toc) {
          _this.AssignRadioButtons(_this.options.toc);

          if (_this.options.selected) {
			this.current = _this.options.selected;
            _this.radios[_this.options.selected].checked = true;
          }
        }

        if (_this.options.title && _this.Node('title')) {
          _this.Node('title').innerHTML = _this.options.title[Core.locale];
        }

        _this.Node('slider').addEventListener("change", _this.onSliderChange_Handler.bind(_assertThisInitialized(_this)));

        return _this;
      }

      _createClass(Legend, [{
        key: "AssignRadioButtons",
        value: function AssignRadioButtons(toc) {
          toc.forEach(function (l) {
            this.radios[l.id] = this.Node('rd_' + l.id);
            this.radios[l.id].addEventListener('change', this.onChange_Handler.bind(this, l.id));
          }.bind(this));
        }
      }, {
        key: "Select",
        value: function Select(layer) {
          if (this.current) {
            this.radios[this.current].checked = false;

            this._map.setLayoutProperty(this.current, 'visibility', 'none');
          }

          this.current = layer;

          this._map.setLayoutProperty(this.current, 'visibility', 'visible');
        }
      }, {
        key: "onChange_Handler",
        value: function onChange_Handler(layer, ev) {
          this.Select(layer);
        }
      }, {
        key: "onSliderChange_Handler",
        value: function onSliderChange_Handler(ev) {
          this.Emit("opacityChanged", {
            opacity: this.opacity
          });
        }
      }, {
        key: "Template",
        value: function Template() {
          var tocHTML = this.options.toc ? this.TocTemplate(this.options.toc) : "";
          var legHTML = this.options.legend ? this.LegendTemplate(this.options.legend) : "";
          return "<div handle='root' class='legend mapboxgl-ctrl mapboxgl-ctrl-group'>" + legHTML + tocHTML + "<div class='legend-label'>nls(Toc_Opacity)</div>" + "<div class='opacity-slider'>" + "<input handle='slider' type='range' min='0' max='100' value='75' class='slider'>" + "</div>" + "</div>";
        }
      }, {
        key: "LegendTemplate",
        value: function LegendTemplate(legend) {
          var html = "";
          this.options.legend.forEach(function (l) {
            var s = "background-color:rgb(".concat(l.color.join(","), ");border:solid thin silver;");
            var l = l.label[Core.locale];
            html += "<div class='legend-item legend-item-1'><div class='legend-icon' style='".concat(s, "'></div><div>").concat(l, "</div></div>");
          });
          return "<div handle='title' class='legend-label'>nls(Toc_Legend)</div>" + "<div class='legend-container'>" + html + "</div>";
        }
      }, {
        key: "TocTemplate",
        value: function TocTemplate(toc) {
          var html = "";
          toc.forEach(function (l) {
            html += "<label>" + "<input handle='rd_" + l.id + "' type='radio' name='boundary'>" + l.label[Core.locale] + "</label>";
          });
          return "<div class='legend-label'>nls(Toc_Instruction)</div>" + "<div class='legend-container toc-container'>" + html + "</div>";
        }
      }]);

      return Legend;
    }(Control);

    var Factory =
    /*#__PURE__*/
    function () {
      function Factory() {
        _classCallCheck(this, Factory);
      }

      _createClass(Factory, null, [{
        key: "Map",
        value: function Map(container, style, center, zoom) {
          return new mapboxgl.Map({
            container: container,
            style: style,
            center: center,
            zoom: zoom
          });
        }
      }, {
        key: "NavigationControl",
        value: function NavigationControl() {
          return new mapboxgl.NavigationControl();
        }
      }, {
        key: "GeolocateControl",
        value: function GeolocateControl() {
          return new mapboxgl.GeolocateControl({
            positionOptions: {
              enableHighAccuracy: true
            },
            trackUserLocation: true
          });
        }
      }, {
        key: "ScaleControl",
        value: function ScaleControl(units) {
          return new mapboxgl.ScaleControl({
            maxWidth: 80,
            unit: units
          });
        }
      }, {
        key: "AttributionControl",
        value: function AttributionControl() {
          return new mapboxgl.AttributionControl({
            compact: true
          });
        }
      }, {
        key: "LegendControl",
        value: function LegendControl(toc, selected, legend, title) {
          return new Legend({
            toc: toc,
            selected: selected,
            legend: legend,
            title: title
          });
        }
      }]);

      return Factory;
    }();

    var Net =
    /*#__PURE__*/
    function () {
      function Net() {
        _classCallCheck(this, Net);
      }

      _createClass(Net, null, [{
        key: "Request",

        /**
        * Execute a web request
        *
        * Parameters :
        *	url : String, the request URL
        *	success : Function, the success callback function
        *	failure : Function, the failure callback function
        * Return : none
        *
        * TODO : This should return a promise object
        *
        */
        value: function Request(url, success, failure) {
          var xhttp = new XMLHttpRequest();

          xhttp.onreadystatechange = function () {
            if (this.readyState != 4) return; // TODO : Switched to this.response, check if it breaks anything

            if (this.status == 200) success(this.response);else failure({
              status: this.status,
              response: this.response
            });
          };

          xhttp.open("GET", url, true);
          xhttp.send();
        }
        /**
        * Get a parameter value from the document URL
        *
        * Parameters :
        *	name : String, the name of the parameter to retrieve from the URL
        * Return : String, the value of the parameter from the URL, an empty string if not found
        */

      }, {
        key: "GetUrlParameter",
        value: function GetUrlParameter(name) {
          name = name.replace(/[\[\]]/g, '\\$&');
          var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)');
          var results = regex.exec(window.location.href);
          if (!results) return null;
          if (!results[2]) return '';
          return decodeURIComponent(results[2].replace(/\+/g, ' '));
        }
        /**
        * Download content as a file
        *
        * Parameters :
        *	name : String, the name of the file to download
        *	content : String, the content to assign to the downloaded file
        * Return : none
        */

      }, {
        key: "Download",
        value: function Download(name, content) {
          var link = document.createElement("a");
          link.href = "data:application/octet-stream," + encodeURIComponent(content);
          link.download = name;
          link.click();
          link = null;
        }
      }]);

      return Net;
    }();

    var cfg = Net.GetUrlParameter("context");
    var Config = config;
    if (cfg == "source") Config = config$1;
    if (cfg == "geometry") Config = config$2;
    if (cfg == "boundary") Config = config;
    if (cfg == "routes") Config = config$3;
    if (cfg == "trips") Config = config$4;
    Core.locale = document.documentElement.lang || "en";
    Core.nls = nls;
    Map.Token = 'pk.eyJ1Ijoic3RhdWJiciIsImEiOiJjanpoaHAxOGcwdnYyM2JsZWxhZDVxbTdsIn0.6N2EV6uBr6fLpdJvCy4_Sw';
    var popup = new Splash(); // TODO : Needs to be converted to promise but stupid ie11

    popup.Show(Initialize);

    function Initialize() {
      var map = Factory.Map('map', 'mapbox://styles/staubbr/ck0r79owi29461cnv5hga13gh', [-75.6972, 45.4215], 11);
      var legend = Factory.LegendControl(Config.toc, Config.selected, Config.legend, Config.title);
      legend.On("opacityChanged", OnLegend_OpacityChanged);
      map.addControl(Factory.NavigationControl(), 'top-left');
      map.addControl(Factory.ScaleControl('metric'));
      map.addControl(legend);
      map.on('load', function (ev) {
        if (Config.selected) map.setLayoutProperty(Config.selected, 'visibility', 'visible'); // Maybe make a classification function in MBT.Map

        var classes = Classes(Config.classes, Config.legend, legend.opacity);
        Map.ReorderLayers(map, Config.layers);
        Map.Choropleth(map, Config.layers, classes);
        Config.layers.forEach(function (l) {
          map.on('click', l, function (ev) {
            if (ev.features.length == 0) return; // var parser = new jsts.io.GeoJSONReader();
            // var f = parser.read(ev.features[0]);

            var html = HTMLize(ev.features[0].properties, Config.fields);
            Map.InfoPopup(map, ev.lngLat, html);
            /*			
            var i = Config.layers.indexOf(l) + 1;
            
            if (i == Config.layers.length) return;
            
            var layer = Config.layers[i].toUpperCase();
            var sublv = map.querySourceFeatures('composite', { 'sourceLayer':layer });
            var intersect = sublv.filter(function(json) {
            	var g = parser.read(json);
            	
            	return f.geometry.intersects(g.geometry);
            });
            	
            map.addLayer({
            	id : 'intersect',
            	type : 'fill',
            	source : {
            		"type": "geojson",
            		"data": {
            			"type": "FeatureCollection",
            			"features": intersect
            		}
            	},
            	paint : {
            		"fill-color": "#B42222"
            	}
            });
            */
          });
        });
      });

      function OnLegend_OpacityChanged(ev) {
        var classes = Classes(Config.classes, Config.legend, ev.opacity);
        Map.Choropleth(map, Config.layers, classes);
      }

      function Classes(classes, legend, opacity) {
        return classes.map(function (c) {
          if (typeof c != 'string') return c;
          var j = c.indexOf('#color');
          if (j == -1) return c;
          var c = legend[c[6] - 1].color;
          return "rgba(".concat(c.join(','), ",").concat(opacity, ")");
        });
      }

      function HTMLize(json, fields) {
        var html = "";
        fields.forEach(function (f) {
          if (!json.hasOwnProperty(f.id) && !f.polish) return;
          var label = f.label[Core.locale];
          var value = f.polish ? polish(json, f.polish, 2) : json[f.id];
          if (f.fixed) value = value.toFixed(f.fixed);
          html += "<div class='row'><span>".concat(label, " : </span><span>").concat(value, "</span></div>");
        });
        return "<div class='popup-inner'>".concat(html, "</div>");
      }

      function polish(json, exp, d) {
        var v1 = json[exp[1]];
        var v2 = json[exp[2]];
        var v = null;
        if (exp[0] == "+") v = v1 + v2;
        if (exp[0] == "-") v = v1 - v2;
        if (exp[0] == "*") v = v1 * v2;
        if (exp[0] == "/") v = v1 / v2;
        return v.toFixed(d);
      }
    }

}());
