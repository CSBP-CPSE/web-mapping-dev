(function () {
	'use strict';

	var nls = {
	  "Legend_Item_1": {
	    "en": "Microsoft buildings",
	    "fr": "Bâtiments de Microsoft"
	  },
	  "Legend_Item_2": {
	    "en": "<abbr title='Open Database of Buildings'>ODB</abbr> Buildings (Stat Can)",
	    "fr": "Bâtiments de la <abbr title='Base de données ouverte des immeubles'>BDOI</abbr> (Stat Can)"
	  },
	  "Toc_Instruction": {
	    "en": "Turn layers on or off",
	    "fr": "Afficher ou cachers les couches"
	  },
	  "Toc_Legend": {
	    "en": "Legend",
	    "fr": "Légende"
	  },
	  "Label_PR": {
	    "en": "Province (PR)",
	    "fr": "Province (PR)"
	  },
	  "Label_CD": {
	    "en": "Census Division (CD)",
	    "fr": "Division de recensement (DR)"
	  },
	  "Label_CSD": {
	    "en": "Census Subdivision (CSD)",
	    "fr": "Sous-division de recensement (SDR)"
	  },
	  "Label_DA": {
	    "en": "Dissemination Area (DA)",
	    "fr": "Aire de diffusion (AD)"
	  },
	  "Label_DB": {
	    "en": "Dissemination Block (DB)",
	    "fr": "Bloc de diffusion (BD)"
	  },
	  "Splash_LODE_Title": {
	    "en": "LODE Viewer",
	    "fr": "Visionneuse de l'ECDO"
	  },
	  "Splash_LODE_1": {
	    "en": "The Linkable Open Data Environment (LODE) is an exploratory initiative that aims at enhancing the use and harmonization of open micro data primarily from municipal, provincial and federal sources.",
	    "fr": "L'Environnement de couplage de données ouvertes (ECDO) est une initiative exploratoire qui vise à accroître l'utilisation et l'harmonisation de microdonnées ouvertes provenant principalement de sources municipales, provinciales et fédérales."
	  },
	  "Splash_LODE_2": {
	    "en": "The results are a collection of datasets released under a single open data license (Open Government Licence - Canada), as well as open source tools used to process the data, and collaborations in an open space.",
	    "fr": "Il en résulte une collection d'ensembles de données diffusés en vertu d'une même licence de données ouvertes (Licence du gouvernement ouvert – Canada), ainsi que des outils libres utilisés pour traiter les données et des collaborations dans un espace ouvert."
	  },
	  "Splash_LODE_3": {
	    "en": "The LODE is implemented by the Data Exploration and Integration Lab (DEIL). Thus, it is an ongoing and exploratory initiative, developed in an open space, as an open project.",
	    "fr": "L'ECDO est mis en œuvre par le Laboratoire d'exploration et d'intégration des données. Il s'agit par conséquent d'une initiative continue et exploratoire mise sur pied dans un espace ouvert à titre de projet ouvert."
	  },
	  "Splash_WIP": {
	    "en": "The LODE Viewer is a work in progress. We are aware of certain issues. Notably, certain census boundaries are incorrect.",
	    "fr": "La visionneuse de l'ECDO est un travail en cours. Nous sommes conscient de certains problèmes. Notamment, certaines limites de recensement sont incorrectes."
	  },
	  "Splash_Warning": {
	    "en": "Warning: This web application consumes a large amount of data. It is advised not to use it on a mobile device with a limited data plan.",
	    "fr": "Attention : Cette application consomme un grand volume de données. Il est conseillé de ne pas l'utiliser sur une plateforme mobile avec un plan de données limité."
	  },
	  "Splash_Continue": {
	    "en": "CONTINUE",
	    "fr": "CONTINUER"
	  }
	};

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  return Constructor;
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function");
	  }

	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf(subClass, superClass);
	}

	function _getPrototypeOf(o) {
	  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
	    return o.__proto__ || Object.getPrototypeOf(o);
	  };
	  return _getPrototypeOf(o);
	}

	function _setPrototypeOf(o, p) {
	  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };

	  return _setPrototypeOf(o, p);
	}

	function _assertThisInitialized(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return self;
	}

	function _possibleConstructorReturn(self, call) {
	  if (call && (typeof call === "object" || typeof call === "function")) {
	    return call;
	  }

	  return _assertThisInitialized(self);
	}

	function _superPropBase(object, property) {
	  while (!Object.prototype.hasOwnProperty.call(object, property)) {
	    object = _getPrototypeOf(object);
	    if (object === null) break;
	  }

	  return object;
	}

	function _get(target, property, receiver) {
	  if (typeof Reflect !== "undefined" && Reflect.get) {
	    _get = Reflect.get;
	  } else {
	    _get = function _get(target, property, receiver) {
	      var base = _superPropBase(target, property);

	      if (!base) return;
	      var desc = Object.getOwnPropertyDescriptor(base, property);

	      if (desc.get) {
	        return desc.get.call(receiver);
	      }

	      return desc.value;
	    };
	  }

	  return _get(target, property, receiver || target);
	}

	var Util =
	/*#__PURE__*/
	function () {
	  function Util() {
	    _classCallCheck(this, Util);
	  }

	  _createClass(Util, null, [{
	    key: "Mixin",

	    /**
	    * Merges an object into another object. 
	    *
	    * Parameters :
	    *	a : Object, the object that will receive the properties 
	    *	b : Object, the object to merge into object A
	    * Return : the modified Object
	    */
	    value: function Mixin(a, b) {
	      for (var key in b) {
	        if (b.hasOwnProperty(key)) a[key] = b[key];
	      } // TODO : Why did I use arguments[0] instead of a?


	      return arguments[0];
	    }
	    /**
	    * Debounces a function. The function will be executed after a timeout 
	    * unless the function is called again in which case, the timeout will
	    * reset
	    *
	    * Parameters :
	    *	delegate : Function, the Function to debounce
	    *	threshold : Integer, the timeout length, in milliseconds
	    * Return : Function, the debounced function
	    */

	  }, {
	    key: "Debounce",
	    value: function Debounce(delegate, threshold) {
	      var timeout;
	      return function debounced() {
	        function delayed() {
	          delegate.apply(this, arguments);
	          timeout = null;
	        }

	        if (timeout) clearTimeout(timeout);
	        timeout = setTimeout(delayed.bind(this), threshold || 100);
	      };
	    }
	    /**
	    * Formats a String using substitute strings
	    *
	    * Parameters :
	    *	str : String, the String to format
	    *	subs : Array(String), An array of Strings to substitute into the String
	    * Return : String, the formatted String
	    */

	  }, {
	    key: "Format",
	    value: function Format(str, subs) {
	      if (!subs || subs.length == 0) return str;
	      var s = str;

	      for (var i = 0; i < subs.length; i++) {
	        var reg = new RegExp("\\{" + i + "\\}", "gm");
	        s = s.replace(reg, subs[i]);
	      }

	      return s;
	    }
	  }]);

	  return Util;
	}();

	var Dom =
	/*#__PURE__*/
	function () {
	  function Dom() {
	    _classCallCheck(this, Dom);
	  }

	  _createClass(Dom, null, [{
	    key: "Node",

	    /**
	    * Retrieve an Element using a selector
	    *
	    * Parameters :
	    *	pNode : Element, the parent node where to begin the search
	    *	selector : String, a selector statement
	    * Return : Element, the Element found, null otherwise
	    */
	    value: function Node(pNode, selector) {
	      return pNode.querySelectorAll(selector).item(0) || null;
	    }
	    /**
	    * Create an Element
	    *
	    * Parameters :
	    *	tagName : String, the type of Element to be created (div, span, label, input, etc.)
	    *	options : Object, a dictionary type object containing the options to assign to the created Element
	    *	pNode : Element, the parent Element where the created Element will be apended
	    * Return : Element, The Element created
	    */

	  }, {
	    key: "Create",
	    value: function Create(tagName, options, pNode) {
	      var elem = document.createElement(tagName);
	      Util.Mixin(elem, options);
	      this.Place(elem, pNode);
	      return elem;
	    }
	    /**
	    * Create an SVG Element
	    *
	    * Parameters :
	    *	tagName : String, the type of SVG Element to be created (rect, path, etc.)
	    *	options : Object, a dictionary type object containing the options to assign to the created SVG Element
	    *	pNode : Element, the parent Element where the created SVG Element will be apended
	    * Return : Element, The SVG Element created
	    */

	  }, {
	    key: "CreateSVG",
	    value: function CreateSVG(tagName, options, pNode) {
	      var elem = document.createElementNS("http://www.w3.org/2000/svg", tagName);

	      for (var id in options) {
	        elem.setAttribute(id, options[id]);
	      }

	      this.Place(elem, pNode);
	      return elem;
	    }
	    /**
	    * Create an Element from a namespace
	    *
	    * Parameters :
	    *	ns : String, the URI namespace containing the Element to create 
	    *	tagName : String, the type of Element to be created (rect, path, etc.)
	    *	options : Object, a dictionary type object containing the options to assign to the created Element
	    *	pNode : Element, the parent Element where the created Element will be apended
	    *
	    * Valid Namespaces are : 
	    *	HTML : http://www.w3.org/1999/xhtml
	    *	SVG  : http://www.w3.org/2000/svg
	    *	XBL  : http://www.mozilla.org/xbl
	    *	XUL  : http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul
	    *
	    * Return : Element, The SVG Element created
	    */

	  }, {
	    key: "CreateNS",
	    value: function CreateNS(ns, tagName, options, pNode) {
	      var elem = document.createElementNS(ns, tagName);

	      for (var id in options) {
	        elem.setAttribute(id, options[id]);
	      }

	      this.Place(elem, pNode);
	      return elem;
	    }
	    /**
	    * Append an Element to another Element
	    *
	    * Parameters :
	    *	elem : Element, the Element to append
	    *	pNode : Element, the parent Element where the Element will be apended
	    * Return : none
	    */

	  }, {
	    key: "Place",
	    value: function Place(elem, pNode) {
	      if (!!pNode) pNode.appendChild(elem);
	    }
	    /**
	    * Replace an Element by another Element
	    *
	    * Parameters :
	    *	elem1 : Element, the Element to be replaced
	    *	elem2 : Element, the Element that will replace elem1
	    * Return : none
	    */

	  }, {
	    key: "Replace",
	    value: function Replace(elem1, elem2) {
	      var pNode = elem1.parentNode;
	      pNode.insertBefore(elem2, elem1);
	      this.Remove(elem1, pNode);
	    }
	    /**
	    * Remove an Element from another Element
	    *
	    * Parameters :
	    *	elem : Element, the Element to remove
	    *	pNode : Element, the parent Element containing the Element to remove
	    * Return : none
	    */

	  }, {
	    key: "Remove",
	    value: function Remove(elem, pNode) {
	      if (!pNode.children.some(function (child) {
	        return child === elem;
	      })) return;
	      pNode.removeChild(elem);
	    }
	    /**
	    * Remove all children of an Element
	    *
	    * Parameters :
	    *	elem : Element, the Element to empty
	    * Return : none
	    */

	  }, {
	    key: "Empty",
	    value: function Empty(elem) {
	      while (elem.firstChild) {
	        elem.removeChild(elem.firstChild);
	      }
	    }
	    /**
	    * Add a CSS rule on an Element
	    *
	    * Parameters :
	    *	elem : Element, the Element to modify
	    *	css : String, the CSS rule to add on the Element
	    * Return : none
	    */

	  }, {
	    key: "AddCss",
	    value: function AddCss(elem, css) {
	      var c1 = elem.className.split(" ");
	      css.split(" ").forEach(function (c) {
	        if (!c1.includes(c)) c1.push(c);
	      });
	      elem.className = c1.join(" ");
	    }
	    /**
	    * Remove a CSS rule on an Element
	    *
	    * Parameters :
	    *	elem : Element, the Element to modify
	    *	css : String, the CSS rule to remove from the Element
	    * Return : none
	    */

	  }, {
	    key: "RemoveCss",
	    value: function RemoveCss(elem, css) {
	      var c1 = elem.className.split(" ");
	      var c2 = css.split(" ");
	      c1.filter(function (c) {
	        return c2.indexOf(c) == -1;
	      });
	      elem.className = classes.join(" ");
	    }
	    /**
	    * Verify that an Element contains a CSS rule
	    *
	    * Parameters :
	    *	elem : Element, the Element to verify
	    *	css : String, the CSS rule to find
	    * Return : Boolean, true if the Element contains the CSS rule, false otherwise
	    */

	  }, {
	    key: "HasCss",
	    value: function HasCss(elem, css) {
	      return (' ' + elem.className + ' ').indexOf(' ' + css + ' ') > -1;
	    }
	    /**
	    * Set the CSS rules on an Element
	    *
	    * Parameters :
	    *	elem : Element, the Element to modify
	    *	css : String, the CSS rule to set on the Element
	    * Return : none
	    */

	  }, {
	    key: "SetCss",
	    value: function SetCss(elem, css) {
	      elem.className = css;
	    }
	    /**
	    * Toggle a CSS rule on or or off for an Element
	    *
	    * Parameters :
	    *	elem : Element, the Element to modify
	    *	css : String, the CSS rule to toggle on the Element
	    *	enabled : Boolean, true to toggle the CSS rule on, false to toggle it off
	    * Return : none
	    */

	  }, {
	    key: "ToggleCss",
	    value: function ToggleCss(elem, css, enabled) {
	      if (enabled) this.AddCss(elem, css);else this.RemoveCss(elem, css);
	    }
	    /**
	    * Get an attribute value from an Element
	    *
	    * Parameters :
	    *	elem : Element, the Element to retrieve the attribute from
	    *	attr : String, the name of the attribute to retrieve
	    * Return : String, the value of the attribute if found, null otherwise
	    */

	  }, {
	    key: "GetAttribute",
	    value: function GetAttribute(elem, attr) {
	      var attr = elem.attributes.getNamedItem(attr);
	      return attr ? attr.value : null;
	    }
	    /**
	    * Set an attribute value on an Element
	    *
	    * Parameters :
	    *	elem : Element, the Element to set the attribute on
	    *	attr : String, the name of the attribute to set
	    *	value : String, the value of the attribute to set
	    * Return : none
	    */

	  }, {
	    key: "SetAttribute",
	    value: function SetAttribute(elem, attr, value) {
	      elem.setAttribute(attr, value);
	    }
	    /**
	    * Get the size of an Element
	    *
	    * Parameters :
	    *	elem : Element, the Element to retrieve the size
	    * Return : Object, an object literal containing the size of the Element
	    * 
	    * { 
	    *	w: width of the Element, 
	    *	h: height of the Element 
	    * }
	    */

	  }, {
	    key: "Size",
	    value: function Size(elem) {
	      var style = window.getComputedStyle(elem);
	      var h = +style.getPropertyValue("height").slice(0, -2);
	      var w = +style.getPropertyValue("width").slice(0, -2);
	      var pL = +style.getPropertyValue("padding-left").slice(0, -2);
	      var pR = +style.getPropertyValue("padding-right").slice(0, -2);
	      var pT = +style.getPropertyValue("padding-top").slice(0, -2);
	      var pB = +style.getPropertyValue("padding-bottom").slice(0, -2);
	      var w = w - pL - pR;
	      var h = h - pT - pB; // Use smallest width as width and height for square grid that fits in container
	      // var s = w < h ? w : h;

	      return {
	        w: w,
	        h: h
	      };
	    }
	  }]);

	  return Dom;
	}();

	var _nls = null;
	var _locale = null;
	var _templatables = {};

	var Core =
	/*#__PURE__*/
	function () {
	  function Core() {
	    _classCallCheck(this, Core);
	  }

	  _createClass(Core, null, [{
	    key: "Nls",

	    /**
	    * Get a localized nls string ressource
	    *
	    * Parameters :
	    *	id : String, the id of the nls ressource to retrieve
	    *	subs : Array(String), an array of Strings to substitute in the localized nls string ressource
	    *	locale : String, the locale for the nls ressource
	    * Return : String, the localized nls string ressource
	    */
	    value: function Nls(id, subs, locale) {
	      if (!this.nls) throw new Error("Nls content not set.");
	      var itm = this.nls[id];
	      if (!itm) throw new Error("Nls String '" + id + "' undefined.");
	      var txt = itm[locale ? locale : this.locale];
	      if (txt === undefined || txt === null) throw new Error("String does not exist for requested language.");
	      return Util.Format(txt, subs);
	    }
	    /**
	    * A convenience function to get a deffered object for asynchronous processing. 
	    * Removes one level of nesting when working with promises
	    *
	    * Parameters :
	    *	none
	    * Return : Object, an object with a Resolve and Reject function
	    *
	    * { 
	    *	promise: the promise object associated to the asynchronous process, 
	    *	Resolve: a function to resolve the promise, 
	    *	Reject: a function to reject the promise 
	    * }
	    */

	  }, {
	    key: "Defer",
	    value: function Defer() {
	      var defer = {};
	      defer.promise = new Promise(function (resolve, reject) {
	        defer.Resolve = function (result) {
	          resolve({
	            result: result
	          });
	        };

	        defer.Reject = function (error) {
	          reject({
	            error: error
	          });
	        };
	      });
	      return defer;
	    }
	    /**
	    * Get or set a templated class definition, this is required to nest Templated UI 
	    * components within other Templated UI components.
	    *
	    * Parameters :
	    *	id : String, the id of the templated class definition to get or set
	    *	definition : Class, when specified, the class definition to set 
	    * Return : Class, the class definition created  
	    */

	  }, {
	    key: "Templatable",
	    value: function Templatable(id, definition) {
	      if (definition) {
	        if (_templatables[id]) throw new Error("Templatable ".concat(id, " is defined multiple times."));else _templatables[id] = definition;
	      } else if (!_templatables[id]) throw new Error("Templatable ".concat(id, " is not defined."));

	      return _templatables[id];
	    }
	    /**
	    * Get an Array of class definitions by matching its
	    *
	    * Parameters :
	    *	id : String, the id of the nls ressource to retrieve
	    *	subs : Array(String), an array of Strings to substitute in the localized nls string ressource
	    *	locale : String, the locale for the nls ressource
	    * Return : String, the localized nls string ressource
	    */

	  }, {
	    key: "Templated",
	    value: function Templated(namespace) {
	      var templated = [];

	      for (var id in _templatables) {
	        if (id.match(namespace)) templated.push(_templatables[id]);
	      }

	      return templated;
	    }
	  }, {
	    key: "nls",

	    /**
	    * Gets the nls ressources
	    *
	    * Return : Object, an object containing the nls ressources
	    */
	    get: function get() {
	      return _nls;
	    }
	    /**
	    * Sets the nls ressources
	    */
	    ,
	    set: function set(value) {
	      _nls = value;
	    }
	    /**
	    * Gets the locale String
	    *
	    * Return : String, a String containing the locale
	    */

	  }, {
	    key: "locale",
	    get: function get() {
	      return _locale;
	    }
	    /**
	    * Sets the locale String
	    */
	    ,
	    set: function set(value) {
	      _locale = value;
	    }
	  }]);

	  return Core;
	}();

	var Evented =
	/*#__PURE__*/
	function () {
	  function Evented() {
	    _classCallCheck(this, Evented);

	    this.listeners = {};
	  }

	  _createClass(Evented, [{
	    key: "addEventListener",
	    value: function addEventListener(type, callback, once) {
	      if (!(type in this.listeners)) this.listeners[type] = [];
	      var h = {
	        target: this,
	        type: type,
	        callback: callback,
	        once: !!once
	      };
	      this.listeners[type].push(h);
	      return h;
	    }
	  }, {
	    key: "removeEventListener",
	    value: function removeEventListener(type, callback) {
	      if (!(type in this.listeners)) return;
	      var stack = this.listeners[type];

	      for (var i = 0, l = stack.length; i < l; i++) {
	        if (stack[i].callback === callback) {
	          stack.splice(i, 1);
	          return this.removeEventListener(type, callback);
	        }
	      }
	    }
	  }, {
	    key: "dispatchEvent",
	    value: function dispatchEvent(event) {
	      if (!(event.type in this.listeners)) return;
	      var stack = this.listeners[event.type];
	      event.target = this;

	      for (var i = 0; i < stack.length; i++) {
	        stack[i].callback.call(this, event);
	      }

	      for (var i = stack.length - 1; i >= 0; i--) {
	        if (!!stack[i].once) this.removeEventListener(event.type, stack[i].callback);
	      }
	    }
	  }, {
	    key: "Emit",
	    value: function Emit(type, data) {
	      var event = {
	        type: type,
	        bubbles: true,
	        cancelable: true
	      };
	      Util.Mixin(event, data);
	      this.dispatchEvent(event);
	    }
	  }, {
	    key: "On",
	    value: function On(type, callback) {
	      return this.addEventListener(type, callback, false);
	    }
	  }, {
	    key: "Once",
	    value: function Once(type, callback) {
	      return this.addEventListener(type, callback, true);
	    }
	  }, {
	    key: "Off",
	    value: function Off(type, callback) {
	      this.removeEventListener(type, callback);
	    }
	  }]);

	  return Evented;
	}();

	var Templated =
	/*#__PURE__*/
	function (_Evented) {
	  _inherits(Templated, _Evented);

	  function Templated(container, options) {
	    var _this;

	    _classCallCheck(this, Templated);

	    _this = _possibleConstructorReturn(this, _getPrototypeOf(Templated).call(this));
	    _this.options = options || {};

	    _this.BuildTemplate();

	    if (_this.template) _this.SetNamedNodes();
	    if (_this.template) _this.BuildSubWidgets();
	    if (container) _this.Place(container);
	    return _this;
	  }

	  _createClass(Templated, [{
	    key: "BuildTemplate",
	    value: function BuildTemplate() {
	      // Use template provided in options first, use Template function second
	      var html = this.options.template ? this.options.template : this.Template(); // TODO : I think it still works with empty templates.

	      if (!html) return; // Trailing whitespaces can cause issues when parsing the template, remove them

	      html = html.trim(); // Replace all nls strings in template. Nls string pattern in templates is nls(StringId)

	      html = this.Replace(html, /nls\((.*?)\)/, function (m) {
	        return Core.Nls(m);
	      });
	      this.template = Dom.Create("div", {
	        innerHTML: html
	      });
	    }
	  }, {
	    key: "SetNamedNodes",
	    value: function SetNamedNodes() {
	      var named = this.template.querySelectorAll("[handle]");
	      this.nodes = {}; // Can't use Array ForEach here since named is a NodeList, not an array

	      for (var i = 0; i < named.length; i++) {
	        var name = Dom.GetAttribute(named[i], "handle");
	        this.nodes[name] = named[i];
	      }
	    }
	  }, {
	    key: "BuildSubWidgets",
	    value: function BuildSubWidgets() {
	      var nodes = this.template.querySelectorAll("[widget]");

	      for (var i = 0; i < nodes.length; i++) {
	        var path = Dom.GetAttribute(nodes[i], "widget");
	        var module = Core.Templatable(path);
	        var widget = new module(nodes[i]);
	        var handle = Dom.GetAttribute(widget.container, "handle");
	        if (handle) this.nodes[handle] = widget;
	      }
	    }
	  }, {
	    key: "Place",
	    value: function Place(container) {
	      this.container = container;
	      if (!this.template) return;

	      while (this.template.children.length > 0) {
	        Dom.Place(this.template.children[0], this.container);
	      }
	    }
	  }, {
	    key: "Template",
	    value: function Template() {
	      return null;
	    }
	  }, {
	    key: "Replace",
	    value: function Replace(str, expr, delegate) {
	      var m = str.match(expr);

	      while (m) {
	        str = str.replace(m[0], delegate(m[1]));
	        m = str.match(expr);
	      }

	      return str;
	    }
	  }, {
	    key: "Node",
	    value: function Node(id) {
	      return this.nodes[id];
	    }
	  }]);

	  return Templated;
	}(Evented);

	var Popup =
	/*#__PURE__*/
	function (_Templated) {
	  _inherits(Popup, _Templated);

	  _createClass(Popup, [{
	    key: "Content",
	    set: function set(content) {
	      this.content = content;
	      Dom.Place(content, this.Node("body"));
	    },
	    get: function get() {
	      return this.content;
	    }
	  }]);

	  function Popup() {
	    var _this;

	    _classCallCheck(this, Popup);

	    _this = _possibleConstructorReturn(this, _getPrototypeOf(Popup).call(this, document.body));
	    _this.content = null;

	    _this.Node("close").addEventListener("click", _this.onBtnClose_Click.bind(_assertThisInitialized(_this)));

	    _this.Hide();

	    return _this;
	  }

	  _createClass(Popup, [{
	    key: "Show",
	    value: function Show() {
	      this.Node("root").style.opacity = 1;
	      this.Node("root").style.visibility = "visible";
	    }
	  }, {
	    key: "Hide",
	    value: function Hide() {
	      this.Node("root").style.opacity = 0;
	      this.Node("root").style.visibility = "hidden";
	    }
	  }, {
	    key: "onBtnClose_Click",
	    value: function onBtnClose_Click(ev) {
	      this.Hide();
	    }
	  }, {
	    key: "Template",
	    value: function Template() {
	      return "<div handle='root' class='popup'>" + "<div class='popup-container'>" + "<div class='popup-header'>" + "<div class='popup-title' handle='title'></div>" + "<button class='close' handle='close'>×</button>" + "</div>" + "<div class='popup-body' handle='body'></div>" + "</div>" + "</div>";
	    }
	  }]);

	  return Popup;
	}(Templated);

	var Splash =
	/*#__PURE__*/
	function (_Popup) {
	  _inherits(Splash, _Popup);

	  function Splash() {
	    var _this;

	    _classCallCheck(this, Splash);

	    _this = _possibleConstructorReturn(this, _getPrototypeOf(Splash).call(this));

	    _this.Node("continue").addEventListener("click", function (ev) {
	      this.onBtnClose_Click(ev);
	      this.callback();
	    }.bind(_assertThisInitialized(_this)));

	    return _this;
	  }

	  _createClass(Splash, [{
	    key: "onBtnClose_Click",
	    value: function onBtnClose_Click(ev) {
	      _get(_getPrototypeOf(Splash.prototype), "onBtnClose_Click", this).call(this, ev);

	      this.callback();
	    }
	  }, {
	    key: "Show",
	    value: function Show(callback) {
	      _get(_getPrototypeOf(Splash.prototype), "Show", this).call(this); // TODO : Need to use promise but stupid ie11


	      this.callback = callback;
	    }
	  }, {
	    key: "Template",
	    value: function Template() {
	      return "<div handle='root' class='popup modal'>" + "<div class='popup-container'>" + "<button class='close' handle='close'>×</button>" + "<div class='popup-body' handle='body'>" + "<h1>nls(Splash_LODE_Title)</h1>" + "<hr>" + "<p class='warning'>nls(Splash_Warning)</p>" + "<hr>" + "<p>nls(Splash_LODE_1)</p>" + "<div class='logo-container'>" + "<img class='logo' src='assets/lode-logo.png' />" + "</div>" + "<p>nls(Splash_LODE_2)</p>" + "<p>nls(Splash_LODE_3)</p>" + "<hr>" + "<div class='wip-container'>" + "<div><img src='assets/warning.png' /></div>" + "<div>nls(Splash_WIP)</div>" + "</div>" + "<div class='continue-container'>" + "<button class='continue' handle='continue'>nls(Splash_Continue)</button>" + "</div>" + "</div>" + "</div>" + "</div>";
	    }
	  }]);

	  return Splash;
	}(Popup);

	var Map =
	/*#__PURE__*/
	function () {
	  function Map() {
	    _classCallCheck(this, Map);
	  }

	  _createClass(Map, null, [{
	    key: "InfoPopup",
	    value: function InfoPopup(map, lngLat, html) {
	      var popup = new mapboxgl.Popup({
	        closeOnClick: true
	      }).setLngLat(lngLat).setHTML(html).addTo(map);
	    }
	  }, {
	    key: "Choropleth",
	    value: function Choropleth(map, layers, classes) {
	      layers.forEach(function (l) {
	        map.setPaintProperty(l, 'fill-color', classes);
	      });
	    }
	  }, {
	    key: "ReorderLayers",
	    value: function ReorderLayers(map, layers) {
	      layers.forEach(function (l) {
	        map.moveLayer(l);
	      });
	    }
	  }, {
	    key: "Token",
	    set: function set(value) {
	      mapboxgl.accessToken = value;
	    },
	    get: function get() {
	      return mapboxgl.accessToken;
	    }
	  }]);

	  return Map;
	}();

	var Utils =
	/*#__PURE__*/
	function () {
	  function Utils() {
	    _classCallCheck(this, Utils);
	  }

	  _createClass(Utils, null, [{
	    key: "HTMLize",
	    value: function HTMLize(json) {
	      var html = "";

	      for (var key in json) {
	        if (key == "tilequery") continue;
	        html += "<div class='row'><span>".concat(key, " : </span><span>\"").concat(json[key], "\"</span></div>");
	      }

	      return "<div class='popup-inner'>".concat(html, "</div>");
	    }
	  }]);

	  return Utils;
	}();

	var Control =
	/*#__PURE__*/
	function (_Templated) {
	  _inherits(Control, _Templated);

	  function Control(options) {
	    var _this;

	    _classCallCheck(this, Control);

	    _this = _possibleConstructorReturn(this, _getPrototypeOf(Control).call(this, null, options));
	    if (!_this.template) throw new Error("MapBox controls cannot be empty");
	    if (_this.template.children.length > 1) throw new Error("MapBox controls should have one root node");
	    _this._container = _this.template.children[0];
	    return _this;
	  }

	  _createClass(Control, [{
	    key: "onAdd",
	    value: function onAdd(map) {
	      this._map = map;
	      return this._container;
	    }
	  }, {
	    key: "onRemove",
	    value: function onRemove() {
	      this._container.parentNode.removeChild(this._container);

	      this._map = undefined;
	    }
	  }]);

	  return Control;
	}(Templated);

	var Legend =
	/*#__PURE__*/
	function (_Control) {
	  _inherits(Legend, _Control);

	  // TODO : All this needs to be made generic
	  function Legend(options) {
	    var _this;

	    _classCallCheck(this, Legend);

	    _this = _possibleConstructorReturn(this, _getPrototypeOf(Legend).call(this, null, options));
	    _this._container = _this.Node('root');
	    _this.radios = {
	      'pr': _this.Node('rdPR'),
	      'cd': _this.Node('rdCD'),
	      'csd': _this.Node('rdCSD'),
	      'da': _this.Node('rdDA'),
	      'db': _this.Node('rdDB')
	    };
	    _this.current = 'csd';
	    _this.radios[_this.current].checked = true;

	    _this.radios.pr.addEventListener('change', _this.onChange_Handler.bind(_assertThisInitialized(_this), 'pr'));

	    _this.radios.cd.addEventListener('change', _this.onChange_Handler.bind(_assertThisInitialized(_this), 'cd'));

	    _this.radios.csd.addEventListener('change', _this.onChange_Handler.bind(_assertThisInitialized(_this), 'csd'));

	    _this.radios.da.addEventListener('change', _this.onChange_Handler.bind(_assertThisInitialized(_this), 'da'));

	    _this.radios.db.addEventListener('change', _this.onChange_Handler.bind(_assertThisInitialized(_this), 'db'));

	    return _this;
	  }

	  _createClass(Legend, [{
	    key: "onChange_Handler",
	    value: function onChange_Handler(layer, ev) {
	      this.radios[this.current].checked = false;

	      this._map.setLayoutProperty(this.current, 'visibility', 'none');

	      this.current = layer;

	      this._map.setLayoutProperty(this.current, 'visibility', 'visible');
	    }
	  }, {
	    key: "Template",
	    value: function Template() {
	      return "<div handle='root' class='legend mapboxgl-ctrl mapboxgl-ctrl-group'>" + "<div class='legend-label'>nls(Toc_Legend)</div>" + "<div class='legend-container'>" + "<div class='legend-item legend-item-1'>" + "<div class='legend-icon'></div>" + "<div>nls(Legend_Item_1)</div>" + "</div>" + "<div class='legend-item legend-item-2'>" + "<div class='legend-icon'></div>" + "<div>nls(Legend_Item_2)</div>" + "</div>" + "</div>" + "<div class='legend-label'>nls(Toc_Instruction)</div>" + "<div class='legend-container toc-container'>" + "<label><input handle='rdPR' type='radio' name='boundary' value='male'>nls(Label_PR)</label>" + "<label><input handle='rdCD' type='radio' name='boundary' value='female'>nls(Label_CD)</label>" + "<label><input handle='rdCSD' type='radio' name='boundary' value='other'>nls(Label_CSD)</label>" + "<label><input handle='rdDA' type='radio' name='boundary' value='other'>nls(Label_DA)</label>" + "<label><input handle='rdDB' type='radio' name='boundary' value='other'>nls(Label_DB)</label>" + "</div>" + "</div>";
	    }
	  }]);

	  return Legend;
	}(Control);

	var Factory =
	/*#__PURE__*/
	function () {
	  function Factory() {
	    _classCallCheck(this, Factory);
	  }

	  _createClass(Factory, null, [{
	    key: "Map",
	    value: function Map(container, style, center, zoom) {
	      return new mapboxgl.Map({
	        container: container,
	        style: style,
	        center: center,
	        zoom: zoom
	      });
	    }
	  }, {
	    key: "NavigationControl",
	    value: function NavigationControl() {
	      return new mapboxgl.NavigationControl();
	    }
	  }, {
	    key: "GeolocateControl",
	    value: function GeolocateControl() {
	      return new mapboxgl.GeolocateControl({
	        positionOptions: {
	          enableHighAccuracy: true
	        },
	        trackUserLocation: true
	      });
	    }
	  }, {
	    key: "ScaleControl",
	    value: function ScaleControl(units) {
	      return new mapboxgl.ScaleControl({
	        maxWidth: 80,
	        unit: units
	      });
	    }
	  }, {
	    key: "AttributionControl",
	    value: function AttributionControl() {
	      return new mapboxgl.AttributionControl({
	        compact: true
	      });
	    }
	  }, {
	    key: "LegendControl",
	    value: function LegendControl() {
	      return new Legend({});
	    }
	  }]);

	  return Factory;
	}();

	Core.locale = document.documentElement.lang || "en";
	Core.nls = nls;
	Map.Token = 'pk.eyJ1Ijoic3RhdWJiciIsImEiOiJjanpoaHAxOGcwdnYyM2JsZWxhZDVxbTdsIn0.6N2EV6uBr6fLpdJvCy4_Sw';
	var popup = new Splash(); // TODO : Needs to be converted to promise but stupid ie11

	popup.Show(Initialize);

	function Initialize() {
	  var map = Factory.Map('map', 'mapbox://styles/staubbr/ck0o66b0h07ed1cplcop73pe4', [-75.6972, 45.4215], 11);
	  map.addControl(Factory.NavigationControl(), 'top-left');
	  map.addControl(Factory.ScaleControl('metric'));
	  map.addControl(Factory.LegendControl());
	  map.on('load', function (ev) {
	    // Maybe make a classification function in MBT.Map
	    var classes = ['case', ['==', ['get', 'Data_prov'], "Microsoft"], 'rgba(0, 140, 220, 0.8)', 'rgba(200, 0, 40, 0.8)'];
	    var layers = ["ab", "bc", "mb", "nb", "nl", "ns", "nt", "nu", "on", "pe", "qc", "sk", "yt"];
	    Map.ReorderLayers(map, layers);
	    Map.Choropleth(map, layers, classes);
	    layers.forEach(function (l) {
	      map.on('click', l, function (ev) {
	        if (ev.features.length == 0) return;
	        var html = Utils.HTMLize(ev.features[0].properties);
	        Map.InfoPopup(map, ev.lngLat, html);
	      });
	    });
	  });
	}

}());
